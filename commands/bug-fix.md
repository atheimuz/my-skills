---
allowed-tools: Bash(git diff:*), Bash(git status:*), Bash(npm test:*), Bash(yarn test:*), Bash(npx:*), Bash(mkdir:*), Read, Write, Glob, Grep, Edit, Task
description: 버그 수정 파이프라인 (분석 → 수정 → 검증 루프)
---

# Bug Fix Command

버그 수정 파이프라인 오케스트레이터. 심각도에 따라 적절한 워크플로우를 실행합니다.
Feature별 버그 수정 기록을 `.claude/bug-report/{feature}/{bug}/report.md`에 관리합니다.

## 사용법

```
/bug-fix
/bug-fix {버그 설명}
```

## 워크플로우

### 파이프라인 개요

**단순 버그 (Minor)**:

```
[이전 기록 확인] → [report.md 생성] → [분석+수정+검증 루프] → [사용자 최종 확인]
```

**복합 버그 (Major/Critical)**:

```
[이전 기록 확인] → [report.md 생성] → [bug-analyzer] → [사용자 확인] → [bug-fixer + 수정 루프] → [regression-tester] → [verification-agent] → [사용자 최종 확인]
```

---

## 실행 절차

### Step 1: 버그 정보 수집

AskUserQuestion으로 버그 정보를 수집합니다:

```yaml
questions:
    - header: "심각도"
      question: "버그의 심각도는 어느 정도인가요?"
      options:
          - label: "Minor"
            description: "UI 오타, 스타일 깨짐 등 기능에 영향 없음"
          - label: "Major"
            description: "주요 기능 오류, 데이터 표시 문제"
          - label: "Critical"
            description: "앱 크래시, 데이터 손실, 보안 이슈"
    - header: "Feature"
      question: "이 버그가 속하는 feature(기능 영역)는 무엇인가요?"
      options:
          - label: "직접 입력"
            description: "feature명을 직접 입력합니다 (예: auth, dashboard, payment)"
```

추가 수집:

- 버그 설명 (이미 인자로 제공된 경우 생략)
- 에러 로그 (있다면)
- 재현 단계 (있다면)

### Step 2: 이전 버그 기록 확인

```bash
# 같은 feature의 이전 버그 기록 스캔
ls .claude/bug-report/{feature}/ 2>/dev/null
```

- `.claude/bug-report/{feature}/` 디렉토리가 존재하면 기존 report.md들을 읽음
- 같은 feature의 이전 버그 수정 기록에서:
    - 유사한 증상이 있었는지 확인
    - 이전에 실패한 접근법 파악
    - 성공한 수정 패턴 참고
- 발견된 관련 기록을 report.md의 "이전 기록 참고" 필드에 기술

### Step 3: 산출물 디렉토리 및 report.md 생성

```bash
# 디렉토리 생성 (feature명은 kebab-case, bug 설명도 kebab-case)
mkdir -p .claude/bug-report/{feature}/{bug-short-description}
```

report.md 초기 내용 작성:

```markdown
# {버그 제목}

## 버그 정보

- **Feature**: {feature}
- **심각도**: Minor | Major | Critical
- **최초 보고일**: {date}
- **상태**: 미해결

## 증상

{버그 설명}

## 에러 로그

{에러 로그 - 없으면 "없음"}

## 재현 단계

1. ...

---

## 수정 시도 #1 - {date}

### 분석

- **근본 원인 추정**: ...
- **영향 범위**: ...
- **이전 기록 참고**: {이전 기록에서 발견한 관련 정보}

### 수정 계획

- [ ] {할 일 1}
- [ ] {할 일 2}
- [ ] 검증: {검증 방법}

### 수정 결과

(수정 완료 후 작성)
```

### Step 4: 수정 루프 (핵심)

#### Minor 버그 (단순 파이프라인)

```
반복 (최대 5회):
  1. report.md에 수정 계획 (todo 체크리스트) 작성
  2. 분석 + 수정 실행
  3. report.md의 todo 항목을 [x]로 체크
  4. 검증 실행 (테스트/빌드/수동 확인)
  5. 해결됨 → report.md 상태를 "해결"로, 수정 결과 기록, 루프 종료
     미해결 → 실패 원인 기록 → 새 "수정 시도 #N" 섹션 추가 → 1로 돌아감
```

- **UI/인터랙션 버그**: Playwright 검증 테스트로 확인
- **그 외 버그**: 단위 테스트 또는 빌드로 확인

### 심각도 분류 보충 규칙

다음 특성을 가진 버그는 Minor처럼 보여도 **Major로 분류**한다:

- 첫 시도와 재시도의 동작이 다른 경우 (상태, 캐시, 초기화 순서 등 내부 조건에 따라 결과가 달라짐)
- 수정 방향이 직관적으로 명확하지 않은 경우 (어느 레이어를 고쳐야 하는지 불분명)
- 프레임워크/플랫폼 내부 상태(이벤트 라우팅, 생명주기, 활성화 상태 등)에 의존하는 동작

Major로 분류 시: formal bug-analyzer 분석 단계를 거친다. 직감 기반 빠른 수정으로 시작하지 않는다.

### 핵심 검증 규칙 (심각도 무관)

**가정 검증 우선 원칙:**

- 프레임워크/런타임 동작(마운트/언마운트 타이밍, 상태 유지 여부, 라이프사이클 순서, 앱 활성화 정책, 윈도우/프로세스 표시 조건, 초기화 순서 등)에 의존하는 구현 시, 가정을 로그 출력(console.log, print, 로그 파일 등) 또는 테스트 코드로 먼저 검증한 후 구현한다.
- "아마 이렇게 동작할 것" 기반의 구현은 금지한다.

**2회 실패 시 전환 규칙:**

- 동일 버그에 대해 같은 접근법(같은 파일/같은 패턴)으로 2회 수정해도 해결되지 않으면, 즉시 로그/테스트로 현재 동작을 진단하여 실제 동작을 확인한 후 접근법을 전환한다.
- 3회 이상 같은 접근법을 반복하지 않는다.
- report.md의 이전 수정 시도 기록이 이 규칙을 자동으로 지원한다.

**자체 검증 루프 (기본 동작):**

- 버그 수정 시 **항상** 한 턴 안에서 수정→빌드→자체검증 루프를 성공할 때까지 반복한다. 사용자의 별도 요청이 없어도 이것이 기본이다.
- 매 반복마다 반드시 자체 검증(바이너리 실행, 테스트, 로그 확인)을 수행한다. 빌드 성공만으로 사용자에게 돌아가지 않는다.
- 3회 반복 후에도 해결되지 않으면 접근법을 전환한다 (2회 실패 시 전환 규칙 적용).
- 총 5회 반복 후에도 미해결 시 현재까지의 진단 결과를 정리하여 사용자에게 보고한다.
- 사용자에게 "확인해주세요"로 검증을 떠넘기는 것은 자체 검증이 기술적으로 불가능한 경우에만 허용된다.

**자체 검증 필수 원칙:**

- 사용자에게 "확인해보세요"라고 요청하기 전에, 가능한 범위에서 자체 검증을 먼저 수행한다.
- 빌드 성공 ≠ 버그 수정 완료. 실제 동작 검증이 필요하다.
- 검증 수단은 프로젝트 유형에 맞게 선택한다:
    - **웹 앱**: dev 서버 + Playwright
    - **네이티브/데스크톱 앱**: 빌드된 바이너리 직접 실행 + 로그 파일(`/tmp/` 등)로 상태 확인
    - **CLI/서버**: 직접 실행 + stdout/stderr 캡처
    - **라이브러리**: 테스트 코드 실행
- **자동화 검증이 불가한 버그** (시각적 렌더링, 외부 디바이스 의존 등): 수동 재현 체크리스트를 작성하여 사용자에게 제공한다. 형식: "[사전 조건 설정] → [재현 단계] → [예상 결과] 확인"

#### Major/Critical 버그 (상세 파이프라인)

**Phase 1: 분석**

```yaml
agent: bug-analyzer
input:
    - 버그 설명, 에러 로그, 재현 단계
    - 이전 버그 기록 (있으면)
output: report.md의 "분석" 섹션 업데이트
```

**사용자 확인**:

```yaml
question: "분석 결과를 확인해주세요. 근본 원인이 맞나요?"
options:
    - "맞습니다, 수정 진행해주세요"
    - "아니요, 추가 분석이 필요합니다"
    - "부분적으로 맞습니다 (추가 설명 제공)"
```

**Phase 2: 수정 루프**

```
반복 (최대 5회):
  1. bug-fixer가 report.md에 수정 계획 작성
  2. 코드 수정 실행
  3. report.md의 todo 항목 체크
  4. regression-tester가 테스트 작성 + 실행
  5. verification-agent가 검증
  6. 해결됨 → report.md 상태 "해결", 수정 결과 기록, 루프 종료
     미해결 → 실패 원인 기록 → 새 "수정 시도 #N" 섹션 추가 → 1로 돌아감
```

**최종 확인**:

```yaml
question: "버그 수정이 완료되었습니다. 추가 작업이 필요한가요?"
options:
    - "완료, 커밋 진행"
    - "수동 테스트 후 확인"
    - "추가 수정 필요"
```

### Step 5: 결과 보고

```markdown
## 버그 수정 완료

### 수정 요약

- **버그**: {설명}
- **원인**: {근본 원인}
- **수정**: {수정 내용}
- **시도 횟수**: {N}회

### 변경된 파일

- `{file1}`: {변경 내용}
- `{file2}`: {변경 내용}

### 테스트 결과

- 새 테스트: {n}/{n} 통과
- 관련 테스트: {n}/{n} 통과

### 버그 리포트

- `.claude/bug-report/{feature}/{bug}/report.md`
```

---

## 수정 결과 기록 형식

각 수정 시도의 "수정 결과" 섹션은 다음과 같이 기록:

```markdown
### 수정 결과

- **결과**: 성공 | 실패 | 부분 해결
- **변경 파일**:
    - `{file1}:{line}`: {변경 내용}
    - `{file2}:{line}`: {변경 내용}
- **검증 내용**: {어떻게 검증했는지}
- **실패 원인** (실패 시): {왜 실패했는지, 다음 시도에서 참고할 점}
```

---

## 프로젝트 컨텍스트

실행 시 자동으로 확인:

1. **CLAUDE.md**: 프로젝트 규칙
2. **package.json**: 테스트 프레임워크, 명령어
3. **테스트 구조**: 기존 테스트 패턴
4. **.claude/bug-report/**: 이전 버그 수정 기록

---

## 에러 처리

### 분석 실패

- 추가 정보 요청
- 에러 로그 재확인

### 수정 실패

- report.md에 실패 원인 기록
- 새 수정 시도 섹션 추가 후 재시도
- 타입/린트 에러 시 즉시 수정

### 테스트 실패

- 실패 원인 분석 후 report.md에 기록
- 수정 또는 사용자 확인 요청

---

## Related Files

- `~/.claude/agents/bug-fix/bug-analyzer.md`
- `~/.claude/agents/bug-fix/bug-fixer.md`
- `~/.claude/agents/bug-fix/regression-tester.md`
- `~/.claude/agents/bug-fix/verification-agent.md`
