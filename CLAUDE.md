# AI 코딩 에이전트 가이드라인

---

## 핵심 원칙

- **증명하기**: "맞는 것 같다"는 완료가 아니다. 테스트/빌드/린트로 검증. 증거 없이 완료 표시 금지.
- **불확실성 명시**: 검증 불가하면 그렇다고 말하고, 가장 안전한 다음 단계를 제안.
- **우아함 추구 (균형 있게)**: 비 trivial 변경 시 "더 단순한 구조가 있는가?" 자문. 단, 스코프를 크게 늘리지 않을 때만.

---

## Plan Mode 규칙

- 계획 작성은 구조적으로, 하지만 각 항목은 간결하게
- 불필요한 세부사항은 생략

### 파일명

- plan 파일명은 내용과 관련된 설명적 이름으로 지정할 것
- 이름 형식: `<동작>-<대상>-<맥락>.md` (예: `setup-auth-system.md`, `refactor-db-schema.md`)
- 랜덤 이름(예: `sparkling-napping-shannon.md`) 사용 금지

## 워크플로우 오케스트레이션

### 계획 모드

- 비 trivial 작업(3단계 이상, 다중 파일, 아키텍처 결정, 프로덕션 영향)은 계획 모드 진입.
- 검증 단계를 계획에 포함 (후순위가 아닌 필수).
- 새 정보로 계획이 무효화되면: **중단** → 계획 갱신 → 계속.
- 요구사항이 모호하면 간결한 스펙 먼저 작성 (입출력, 엣지 케이스, 성공 기준).

### 서브에이전트 전략

- 메인 컨텍스트를 깨끗하게 유지하고 병렬화를 위해 서브에이전트 사용.
- 각 서브에이전트에 **하나의 집중된 목표**와 구체적 산출물.
    - "X가 어디에 구현되어 있는지 찾고 파일 + 핵심 함수 나열" > "둘러보기".
- 서브에이전트 결과를 짧고 실행 가능한 종합으로 병합한 후 코딩.

### 점진적 전달

- 빅뱅 변경보다 **얇은 수직 슬라이스**: 구현 → 테스트 → 검증 → 확장.

---

## 에러 대응

### "라인 중단" 규칙

예상치 못한 일 발생 시 (테스트 실패, 빌드 에러, 동작 회귀):

- 기능 추가 **즉시 중단**
- 증거 보존 (에러 출력, 재현 단계)
- 진단으로 돌아가서 재계획

### 트리아지 체크리스트 (순서대로)

1. **재현** — 안정적으로 (테스트, 스크립트, 최소 단계).
2. **위치 파악** — 어느 레이어인지 (UI, API, DB, 네트워크, 빌드 도구).
3. **축소** — 최소 실패 케이스로.
4. **수정** — 근본 원인 (증상 아님).
5. **방어** — 회귀 커버리지 추가.
6. **검증** — 원래 리포트 기준 E2E.

### 자율 버그 수정

- 재현 → 근본 원인 분리 → 수정 → 회귀 커버리지 추가 → 검증.
- 정말 막힌 경우가 아니면 디버깅 작업을 사용자에게 넘기지 않는다.

---

## 교훈 기록 (LESSONS.md)

- 실수나 사용자 교정 발생 시 `LESSONS.md`에 기록 (실패 모드, 감지 신호, 예방 규칙)
- 대규모 작업 전에 복습
- 템플릿: `~/.claude/templates/lessons.md` 참조

---

## 커뮤니케이션

- **막혔을 때**: **하나의** 타겟 질문 + 기본값 추천 + 답에 따라 뭐가 바뀌는지 명시.
- **검증 스토리 필수**: 뭘 실행했고(테스트/린트/빌드), 결과가 뭔지 항상 포함.
- **가정과 제약 명시**: 요구사항을 추론했으면 간단히 나열. 검증 못 했으면 이유와 방법 안내.
- 변경 전후 동작 비교. 자문: "시니어 엔지니어가 이 diff와 검증 스토리를 승인할까?"

---

## 완료 정의

- 동작이 인수 조건과 일치.
- 테스트/린트/타입체크/빌드 통과 (또는 미실행 사유 문서화).
- 코드가 기존 컨벤션을 따르고 읽기 쉬움.
- 짧은 검증 스토리 존재.
